<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Memory Grid</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            touch-action: manipulation; /* Prevent double-tap zoom */
        }

        .tile {
            transition: all 0.2s ease-in-out;
            cursor: pointer;
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            position: relative;
            overflow: hidden;
        }

        .tile:active {
            transform: scale(0.95);
        }

        /* Tile States */
        .tile-default {
            background-color: #cbd5e1; /* slate-300 */
        }
        
        .tile-default:hover {
            background-color: #94a3b8; /* slate-400 */
        }

        .tile-pattern {
            background-color: #0ea5e9; /* sky-500 */
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(14, 165, 233, 0.5);
        }

        .tile-correct {
            background-color: #22c55e; /* green-500 */
            animation: pop 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .tile-wrong {
            background-color: #ef4444; /* red-500 */
            animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both;
        }

        .tile-missed {
            background-color: #f59e0b; /* amber-500 */
            opacity: 0.7;
        }

        /* Animations */
        @keyframes pop {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }

        /* Grid Container Dynamic Resizing */
        #game-board {
            display: grid;
            gap: 0.5rem; /* Gap-2 equivalent */
            margin: 0 auto;
            max-width: 90vw;
            max-height: 60vh;
            /* Aspect ratio handling via JS usually, but CSS grid handles flow well */
        }

        /* Overlay */
        .overlay {
            backdrop-filter: blur(4px);
            background-color: rgba(255, 255, 255, 0.8);
        }
    </style>
</head>
<body class="h-screen w-screen flex flex-col overflow-hidden text-slate-800 selection:bg-sky-200">

    <!-- Header / HUD -->
    <header class="flex-none p-4 md:p-6 flex justify-between items-center bg-white shadow-sm z-10">
        <div class="flex items-center gap-3">
            <div class="bg-sky-500 text-white p-2 rounded-lg">
                <i class="fa-solid fa-brain text-xl"></i>
            </div>
            <div>
                <h1 class="font-bold text-xl leading-none">Memory Grid</h1>
                <p class="text-xs text-slate-500 font-semibold">BRAIN TRAINING</p>
            </div>
        </div>

        <div class="flex gap-6 text-sm md:text-base">
            <div class="text-center">
                <p class="text-slate-400 text-xs font-bold uppercase tracking-wider">Score</p>
                <p id="score-display" class="font-bold text-xl tabular-nums">0</p>
            </div>
            <div class="text-center">
                <p class="text-slate-400 text-xs font-bold uppercase tracking-wider">Level</p>
                <p id="level-display" class="font-bold text-xl tabular-nums">1</p>
            </div>
            <div class="text-center hidden md:block">
                <p class="text-slate-400 text-xs font-bold uppercase tracking-wider">Tiles</p>
                <p id="tiles-count-display" class="font-bold text-xl tabular-nums">3</p>
            </div>
        </div>
    </header>

    <!-- Main Game Area -->
    <main class="flex-grow flex items-center justify-center relative p-4 bg-slate-100">
        
        <!-- The Grid -->
        <div id="game-board-container" class="relative">
            <div id="game-board">
                <!-- Tiles generated by JS -->
            </div>
        </div>

        <!-- Start / Game Over Overlay -->
        <div id="overlay" class="absolute inset-0 z-20 flex flex-col items-center justify-center overlay transition-opacity duration-300">
            <div class="bg-white p-8 rounded-2xl shadow-2xl text-center max-w-sm w-full mx-4 border border-slate-100">
                <div class="mb-6 inline-flex items-center justify-center w-20 h-20 rounded-full bg-sky-100 text-sky-600 mb-4">
                    <i id="overlay-icon" class="fa-solid fa-play text-3xl"></i>
                </div>
                
                <h2 id="overlay-title" class="text-2xl font-black mb-2 text-slate-800">Ready?</h2>
                <p id="overlay-message" class="text-slate-600 mb-8 leading-relaxed">Memorize the pattern of blue tiles, then tap them when they disappear.</p>
                
                <button id="action-btn" class="w-full bg-sky-600 hover:bg-sky-700 text-white font-bold py-4 px-6 rounded-xl transition-transform hover:-translate-y-1 active:translate-y-0 shadow-lg shadow-sky-200">
                    Start Game
                </button>
            </div>
        </div>

        <!-- Floating Feedback Toast -->
        <div id="feedback" class="absolute top-4 left-1/2 transform -translate-x-1/2 bg-slate-800 text-white px-6 py-2 rounded-full text-sm font-semibold opacity-0 transition-opacity duration-300 pointer-events-none">
            Perfect!
        </div>
    </main>

    <!-- Progress Bar (Timer logic could be added here, currently just decorative or strictly level progress) -->
    <div class="h-2 bg-slate-200 w-full">
        <div id="progress-bar" class="h-full bg-sky-500 transition-all duration-500" style="width: 0%"></div>
    </div>

    <script>
        /**
         * Game Configuration and State
         */
        const CONFIG = {
            baseGridSize: 3,
            startTiles: 3,
            patternShowTime: 1500, // ms
            postRoundDelay: 1000, // ms
            scorePerTile: 100,
            scoreMultiplier: 1.5 // Multiplier for higher levels
        };

        const STATE = {
            level: 1,
            score: 0,
            gridSize: 3, // 3x3
            numTiles: 3,
            pattern: [], // Array of indices
            userPattern: [],
            isInputActive: false,
            isPlaying: false
        };

        // DOM Elements
        const boardEl = document.getElementById('game-board');
        const overlayEl = document.getElementById('overlay');
        const actionBtn = document.getElementById('action-btn');
        const scoreDisplay = document.getElementById('score-display');
        const levelDisplay = document.getElementById('level-display');
        const tilesCountDisplay = document.getElementById('tiles-count-display');
        const overlayTitle = document.getElementById('overlay-title');
        const overlayMessage = document.getElementById('overlay-message');
        const overlayIcon = document.getElementById('overlay-icon');
        const progressBar = document.getElementById('progress-bar');
        const feedbackEl = document.getElementById('feedback');

        // Audio Context (Simple synthesized beeps)
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            if (type === 'flip') {
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(400, audioCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.1);
                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'correct') {
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(600, audioCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.15);
                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 0.15);
            } else if (type === 'wrong') {
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(200, audioCtx.currentTime);
                oscillator.frequency.linearRampToValueAtTime(100, audioCtx.currentTime + 0.3);
                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 0.3);
            }
        }

        /**
         * Game Logic
         */

        function initGame() {
            STATE.level = 1;
            STATE.score = 0;
            STATE.gridSize = CONFIG.baseGridSize;
            STATE.numTiles = CONFIG.startTiles;
            STATE.isPlaying = true;
            updateHUD();
            startLevel();
            
            // Hide overlay
            overlayEl.classList.add('opacity-0', 'pointer-events-none');
        }

        function calculateDifficulty() {
            // Logic to scale difficulty
            // Every 3 levels, increase grid size
            // Every level, increase tiles (reset when grid grows)
            
            // Simple Progression Algorithm:
            // Lvl 1: 3x3, 3 tiles
            // Lvl 2: 3x3, 4 tiles
            // Lvl 3: 4x4, 4 tiles
            // Lvl 4: 4x4, 5 tiles
            // Lvl 5: 4x4, 6 tiles
            // Lvl 6: 5x5, 6 tiles
            // ...
            
            if (STATE.level === 1) {
                STATE.gridSize = 3;
                STATE.numTiles = 3;
            } else {
                // Just a rough curve
                STATE.numTiles++;
                
                // If tiles cover more than 40% of grid, expand grid
                const totalCells = STATE.gridSize * STATE.gridSize;
                if (STATE.numTiles > totalCells * 0.45) {
                    STATE.gridSize++;
                    // Slightly reduce tiles when grid expands to give a breather, but keep it challenging
                    // Or keep tiles same, but bigger space makes it harder anyway.
                }
                
                // Cap Grid Size at 6x6 for mobile usability, maybe 7x7 desktop
                if (STATE.gridSize > 6) STATE.gridSize = 6;
            }
        }

        function startLevel() {
            STATE.isInputActive = false;
            STATE.userPattern = [];
            STATE.pattern = [];
            
            if (STATE.level > 1) calculateDifficulty();
            
            updateHUD();
            renderGrid();
            
            // Short delay before showing pattern
            setTimeout(() => {
                generatePattern();
                showPattern();
            }, 500);
        }

        function renderGrid() {
            boardEl.innerHTML = '';
            
            // Set grid columns CSS
            boardEl.style.gridTemplateColumns = `repeat(${STATE.gridSize}, 1fr)`;
            
            // Calculate tile size based on viewport to keep it square and fitting
            // Base size calc: (Min(90vw, 60vh) - gaps) / gridSize
            const viewportSize = Math.min(window.innerWidth * 0.9, window.innerHeight * 0.6);
            const gapSize = 8 * (STATE.gridSize - 1); // 0.5rem = 8px
            const tileSize = Math.floor((viewportSize - gapSize) / STATE.gridSize);
            
            const totalCells = STATE.gridSize * STATE.gridSize;

            for (let i = 0; i < totalCells; i++) {
                const tile = document.createElement('div');
                tile.className = 'tile tile-default';
                tile.style.width = `${tileSize}px`;
                tile.style.height = `${tileSize}px`;
                tile.dataset.index = i;
                tile.addEventListener('click', () => handleTileClick(i));
                
                // prevent drag
                tile.ondragstart = () => false;
                
                boardEl.appendChild(tile);
            }
        }

        function generatePattern() {
            const totalCells = STATE.gridSize * STATE.gridSize;
            const indices = Array.from({length: totalCells}, (_, i) => i);
            
            // Fisher-Yates Shuffle
            for (let i = indices.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [indices[i], indices[j]] = [indices[j], indices[i]];
            }
            
            STATE.pattern = indices.slice(0, STATE.numTiles);
        }

        function showPattern() {
            const tiles = document.querySelectorAll('.tile');
            
            // Reveal
            STATE.pattern.forEach(index => {
                const tile = tiles[index];
                if(tile) {
                    tile.classList.remove('tile-default');
                    tile.classList.add('tile-pattern');
                }
            });
            
            playSound('flip');

            // Hide after delay
            setTimeout(() => {
                STATE.pattern.forEach(index => {
                    const tile = tiles[index];
                    if(tile) {
                        tile.classList.remove('tile-pattern');
                        tile.classList.add('tile-default');
                    }
                });
                STATE.isInputActive = true;
                showFeedback("Go!", "text-white");
            }, CONFIG.patternShowTime); // Time to memorize
        }

        function handleTileClick(index) {
            if (!STATE.isInputActive) return;
            
            // Ignore if already clicked (check class list for correct/wrong)
            const tile = document.querySelectorAll('.tile')[index];
            if (tile.classList.contains('tile-correct') || tile.classList.contains('tile-wrong')) return;

            // Check correctness
            if (STATE.pattern.includes(index)) {
                // Correct
                tile.classList.remove('tile-default');
                tile.classList.add('tile-correct');
                playSound('correct');
                
                STATE.userPattern.push(index);
                
                // Check if level complete
                if (STATE.userPattern.length === STATE.pattern.length) {
                    levelComplete();
                }
            } else {
                // Wrong
                tile.classList.remove('tile-default');
                tile.classList.add('tile-wrong');
                playSound('wrong');
                
                gameOver();
            }
        }

        function levelComplete() {
            STATE.isInputActive = false;
            
            // Score Calc
            const levelBonus = STATE.level * 50;
            const points = (STATE.numTiles * CONFIG.scorePerTile) + levelBonus;
            STATE.score += points;
            
            showFeedback("Perfect!", "bg-green-500");
            
            STATE.level++;
            updateHUD();
            
            setTimeout(startLevel, CONFIG.postRoundDelay);
        }

        function gameOver() {
            STATE.isInputActive = false;
            STATE.isPlaying = false;
            
            // Show missed tiles
            const tiles = document.querySelectorAll('.tile');
            STATE.pattern.forEach(index => {
                const tile = tiles[index];
                if (!tile.classList.contains('tile-correct')) {
                    tile.classList.add('tile-missed');
                }
            });

            setTimeout(() => {
                showOverlay('Game Over', `You reached Level ${STATE.level} with a score of ${STATE.score}.`, 'fa-rotate-right');
            }, 1500);
        }

        function showOverlay(title, msg, iconClass) {
            overlayTitle.innerText = title;
            overlayMessage.innerText = msg;
            overlayIcon.className = `fa-solid ${iconClass} text-3xl`;
            actionBtn.innerText = title === 'Game Over' ? 'Try Again' : 'Start Game';
            
            overlayEl.classList.remove('opacity-0', 'pointer-events-none');
        }

        function updateHUD() {
            scoreDisplay.innerText = STATE.score.toLocaleString();
            levelDisplay.innerText = STATE.level;
            tilesCountDisplay.innerText = STATE.numTiles;
            
            // Update progress bar (visual flair, fills based on tiles found in current level)
            // But we don't track incremental progress in HUD easily, so maybe just level progress
            // Let's make progress bar show difficulty roughly (tiles / total)
            const percentage = (STATE.numTiles / (STATE.gridSize * STATE.gridSize)) * 100;
            progressBar.style.width = `${percentage}%`;
        }
        
        function showFeedback(text, colorClass) {
            feedbackEl.innerText = text;
            feedbackEl.className = `absolute top-4 left-1/2 transform -translate-x-1/2 px-6 py-2 rounded-full text-sm font-semibold transition-all duration-300 pointer-events-none shadow-lg ${colorClass || 'bg-slate-800 text-white'}`;
            feedbackEl.style.opacity = '1';
            feedbackEl.style.transform = 'translate(-50%, 0)';
            
            setTimeout(() => {
                feedbackEl.style.opacity = '0';
                feedbackEl.style.transform = 'translate(-50%, -10px)';
            }, 800);
        }

        // Event Listeners
        actionBtn.addEventListener('click', initGame);

        // Resize observer to handle window resizing dynamically
        window.addEventListener('resize', () => {
            if (STATE.isPlaying) {
                renderGrid();
                // We need to restore the state of tiles (correct, patterns etc)
                // This is complex, for a simple clone, we might just let the user finish or restart
                // For now, re-rendering clears the visual state, which is bad during a game.
                // A better approach for resize is just updating CSS vars, but since we calc px in JS:
                // Let's actually NOT re-render the DOM, just update the width/height of existing tiles.
                const viewportSize = Math.min(window.innerWidth * 0.9, window.innerHeight * 0.6);
                const gapSize = 8 * (STATE.gridSize - 1);
                const tileSize = Math.floor((viewportSize - gapSize) / STATE.gridSize);
                const tiles = document.querySelectorAll('.tile');
                tiles.forEach(t => {
                    t.style.width = `${tileSize}px`;
                    t.style.height = `${tileSize}px`;
                });
            }
        });

    </script>
</body>
</html>
